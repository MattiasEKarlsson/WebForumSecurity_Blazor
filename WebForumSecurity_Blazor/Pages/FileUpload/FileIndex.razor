@page "/files"

@using System 
@using System.IO
@using Microsoft.AspNetCore.Hosting
@using Microsoft.Extensions.Logging
@using System.Web
@using WebForumSecurity_Blazor.FileTypes
@using WebForumSecurity_Blazor.Models
@using BlazorInputFile
@using System.Net.Http
@using WebForumSecurity_Blazor.Verify
@inject IFileHandler FileHandler
@inject IWebHostEnvironment Environment
@inject IJSRuntime JS

<h3>Upload Files</h3>

<InputFile OnChange="UploadFile"  class="btn-primary"/>
<h5 class="text-danger">@Message</h5>
       

<table class="table">
    <thead>
        <tr>
            <th>
                Uploaded
            </th>
            <th>
                Name
            </th>
            <th>
                Size
            </th>            
            <th></th>
        </tr>
    </thead>
    <tbody>
@foreach (var file in Files) {
        <tr>
            <td>
                @file.TimeStamp
            </td>
            <td>
                @file.UntrustedName
            </td>
            <td>
                @file.Size
            </td>            
            <td>     
                 <button @onclick="()=>DownloadFileFromStream(file.Id)" class="btn btn-primary" >Download</button>
                 <button @onclick="()=>Delete(file.Id)" class="btn btn-danger">Delete</button>
            </td>
        </tr>
}
    </tbody>
</table>

@code {
    private ApplicationFile selectedFile = new ApplicationFile();
    private byte[]? FileUploaded;
    private IEnumerable<ApplicationFile> Files { get; set; } = new List<ApplicationFile>();

    private long maxFileSize = 2097152;
    private string[] permittedExtensions = { ".txt", ".jpg", ".png"};
    private string? Message;
    private FileTypeVerifier verifyer = new FileTypeVerifier();


    protected override async Task OnInitializedAsync()
    {
        Files = await FileHandler.GetAllFiles();
    }

    private async Task DownloadFileFromStream(Guid id)
    {
        var applicationFile = await FileHandler.DownloadFile(id);
        var fileStream = GetFileStream(applicationFile.Data);
        var fileName = applicationFile.UntrustedName;

        using var streamRef = new DotNetStreamReference(stream: fileStream);
        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private Stream GetFileStream(byte[] filebyte)
    {
        var fileStream = new MemoryStream(filebyte);
        return fileStream;
    }

    private async Task Delete(Guid id)
    {
        await FileHandler.Delete(id);
        NavManager.NavigateTo("files", true);
    }

    private async Task UploadFile(IFileListEntry[] files)
    {

        var file = files.FirstOrDefault();
        if (file != null)
        {
            var ext = Path.GetExtension(file.Name).ToLowerInvariant();

            if (file.Size < maxFileSize && permittedExtensions.Contains(ext))
            {
                var ms = new MemoryStream();
                await file.Data.CopyToAsync(ms);
                //var isVerigyed = verifyer.What(file.Data);

                //if (isVerigyed)
                //{
                   FileUploaded = ms.ToArray();
                   selectedFile.Id = new Guid();
                   selectedFile.UntrustedName = ChangeName(file.Name);
                   selectedFile.TimeStamp = DateTime.Now;
                   selectedFile.Size = file.Size;
                   selectedFile.Data = FileUploaded;
                   await FileHandler.UploadFile(selectedFile);
                   NavManager.NavigateTo("files", true);
                //}
                //else
                //{
                //     Message = "Invalid File Format";
                //}
            }
            else
            {
                Message = "Invalid File Size or Format";
            }
        }
    }

    private  string ChangeName(string name)
    {
        int lenth = name.Count()/2-1;
        var newName = name.Insert(lenth, Path.GetRandomFileName());
        return newName;
    }

 
   

       


}



